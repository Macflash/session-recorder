{"version":3,"sources":["getusermedia.js","visualizer.tsx","clipInfo.tsx","recorder.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["promisifiedOldGUM","constraints","successCallback","errorCallback","getUserMedia","navigator","webkitGetUserMedia","mozGetUserMedia","msGetUserMedia","Promise","call","reject","Error","polyfillGUM","undefined","mediaDevices","Visualizer","_Component","_getPrototypeOf2","_this","Object","classCallCheck","this","_len","arguments","length","args","Array","_key","possibleConstructorReturn","getPrototypeOf","apply","concat","clipCanvas","inherits","createClass","key","value","canvasCtx","getContext","WIDTH","width","HEIGHT","height","fillStyle","fillRect","lineWidth","strokeStyle","sliceWidth","props","waveform","x","lastX","lastY","i","y","beginPath","moveTo","lineTo","stroke","_this2","react_default","a","createElement","ref","c","setState","style","flex","Component","ClipInfo","clipInfo","display","flexDirection","trackNumber","visualizer_Visualizer","controls","src","audioUrl","name","Recorder","mediaRecorder","lastNoiseCounter","chunks","trackCount","record","start","status","pause","resume","split","stop","console","log","audio","then","stream","audioContext","AudioContext","audioSource","createMediaStreamSource","analyser","createAnalyser","connect","bufferLength","fftSize","dataArray","Uint8Array","canvas","document","querySelector","draw","requestAnimationFrame","getByteTimeDomainData","from","state","slice","min","max","forEach","v","Math","MediaRecorder","mimeType","audioBitsPerSecond","onstart","e","ondataavailable","push","data","onstop","blob","Blob","type","window","URL","createObjectURL","clips","toConsumableArray","link","href","download","body","appendChild","catch","err","error","_this$state","overflow","minHeight","map","clip","clipInfo_ClipInfo","className","onClick","App","recorder_Recorder","Boolean","location","hostname","match","ReactDOM","render","src_App_0","getElementById","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.c8708d5d.chunk.js","sourcesContent":["export var promisifiedOldGUM = function (constraints, successCallback, errorCallback) {\r\n    // First get ahold of getUserMedia, if present\r\n    var getUserMedia = (navigator.getUserMedia ||\r\n        navigator.webkitGetUserMedia ||\r\n        navigator.mozGetUserMedia ||\r\n        navigator.msGetUserMedia);\r\n\r\n    // Some browsers just don't implement it - return a rejected promise with an error\r\n    // to keep a consistent interface\r\n    if (!getUserMedia) {\r\n        return Promise.reject(new Error('getUserMedia is not implemented in this browser'));\r\n    }\r\n\r\n    // Otherwise, wrap the call to the old navigator.getUserMedia with a Promise\r\n    return new Promise(function (successCallback, errorCallback) {\r\n        getUserMedia.call(navigator, constraints, successCallback, errorCallback);\r\n    });\r\n\r\n}\r\n\r\nexport var polyfillGUM = function () {\r\n    // Older browsers might not implement mediaDevices at all, so we set an empty object first\r\n    if (navigator.mediaDevices === undefined) {\r\n        navigator.mediaDevices = {};\r\n    }\r\n\r\n    // Some browsers partially implement mediaDevices. We can't just assign an object\r\n    // with getUserMedia as it would overwrite existing properties.\r\n    // Here, we will just add the getUserMedia property if it's missing.\r\n    if (navigator.mediaDevices.getUserMedia === undefined) {\r\n        navigator.mediaDevices.getUserMedia = promisifiedOldGUM;\r\n    }\r\n}","import React, { Component } from 'react';\r\n\r\nexport interface IVisualizerProps {\r\n    waveform: number[];\r\n}\r\n\r\nexport interface IVisualizerState {\r\n    clipCanvas?: HTMLCanvasElement;\r\n}\r\n\r\nexport class Visualizer extends Component<IVisualizerProps, IVisualizerState> {\r\n    clipCanvas: HTMLCanvasElement | null = null;\r\n\r\n    componentDidUpdate() {\r\n        if (!this.clipCanvas) { return; }\r\n        var canvasCtx = this.clipCanvas.getContext(\"2d\") as CanvasRenderingContext2D;\r\n\r\n        var WIDTH = this.clipCanvas.width\r\n        var HEIGHT = this.clipCanvas.height;\r\n\r\n        canvasCtx.fillStyle = 'rgb(255, 255, 255)';\r\n        canvasCtx.fillRect(0, 0, WIDTH, HEIGHT);\r\n\r\n        canvasCtx.lineWidth = 2;\r\n        canvasCtx.strokeStyle = 'rgb(0, 0, 0)';\r\n\r\n\r\n        var sliceWidth = WIDTH * 1.0 / this.props.waveform.length;\r\n        var x = 0;\r\n\r\n        var lastX = 0;\r\n        var lastY = HEIGHT / 2;\r\n\r\n        for (var i = 0; i < this.props.waveform.length; i++) {\r\n            var v = this.props.waveform[i] / 128.0;\r\n            var y = v * HEIGHT / 2;\r\n\r\n            if (this.props.waveform[i] > 140 || this.props.waveform[i] < 100) {\r\n                canvasCtx.strokeStyle = 'rgb(255, 0, 0)';\r\n            }\r\n            else {\r\n                canvasCtx.strokeStyle = 'rgb(0, 0, 0)';\r\n            }\r\n\r\n            canvasCtx.beginPath();\r\n            canvasCtx.moveTo(lastX, lastY);\r\n            canvasCtx.lineTo(x, y);\r\n            canvasCtx.stroke();\r\n\r\n            lastX = x;\r\n            lastY = y;\r\n\r\n            x += sliceWidth;\r\n        }\r\n    }\r\n\r\n    render() {\r\n        return <canvas height=\"50\" ref={c => { if(!this.clipCanvas && c){\r\n            this.clipCanvas = c;\r\n            this.setState({clipCanvas: c});\r\n        } }} style={{ flex: \"auto\" }} />;\r\n    }\r\n}","import React, { Component } from 'react';\r\nimport { Visualizer } from './visualizer';\r\n\r\nexport interface IClipInfo {\r\n    audioUrl: string;\r\n    name: string;\r\n\r\n    //todo: add other information like length, date and wave preview\r\n    waveform: number[];\r\n    trackNumber: number;\r\n}\r\n\r\nexport interface IClipInfoProps {\r\n    clipInfo: IClipInfo;\r\n}\r\n\r\nexport class ClipInfo extends Component<IClipInfoProps> {\r\n    clipCanvas: HTMLCanvasElement | null = null;\r\n\r\n    render() {\r\n        const { clipInfo } = this.props;\r\n        return (\r\n            <div style={{ display: \"flex\", flexDirection: \"row\", height: \"100px\" }}>\r\n                <div style={{ flex: \"none\" }}>{clipInfo.trackNumber}</div>\r\n                <div style={{ flex: \"auto\", display: \"flex\", flexDirection: \"column\" }}>\r\n                    <Visualizer waveform={clipInfo.waveform} />\r\n                    <audio controls src={clipInfo.audioUrl} />\r\n                </div>\r\n                <div style={{ flex: \"none\", display: \"flex\", flexDirection: \"column\" }}>\r\n                    <div style={{ flex: \"none\" }}>\r\n                        {clipInfo.name}\r\n                    </div>\r\n                    <div style={{ flex: \"none\" }}>\r\n                        <button>Edit</button>\r\n                        <button>Delete</button>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}","import { polyfillGUM } from \"./getusermedia\";\r\nimport React, { Component } from 'react';\r\nimport { ClipInfo, IClipInfo } from \"./clipInfo\";\r\n\r\nexport interface IRecorderProps {\r\n\r\n}\r\n\r\nexport interface IRecorderState {\r\n    clips: IClipInfo[];\r\n    status: \"initializing\" | \"ready\" | \"armed\" | \"recording\" | \"done\" | \"paused\"; // it looks like mediarecorder is reusable after stopping.\r\n    recording?: \"waiting for audio\" | \"detected sound recently\" | \"recording a track\";\r\n}\r\n\r\n\r\nexport class Recorder extends Component<IRecorderProps, IRecorderState> {\r\n    private mediaRecorder?: MediaRecorder;\r\n\r\n    private lastNoiseCounter = 0;\r\n\r\n    // currently recording chunks\r\n    private chunks: Blob[] = [];\r\n\r\n    // currently recording chunks\r\n    private waveform: number[] = [];\r\n\r\n    private trackCount = 1;\r\n\r\n    constructor(props: IRecorderProps) {\r\n        super(props);\r\n        polyfillGUM();\r\n        if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\r\n            console.log('getUserMedia supported.');\r\n            navigator.mediaDevices.getUserMedia({ audio: true })\r\n                .then(stream => {\r\n                    var audioContext = new AudioContext();\r\n\r\n                    var audioSource = audioContext.createMediaStreamSource(stream);\r\n                    var analyser = audioContext.createAnalyser();\r\n                    audioSource.connect(analyser);\r\n                    var bufferLength = analyser.fftSize;\r\n                    console.log(bufferLength);\r\n                    var dataArray = new Uint8Array(bufferLength);\r\n\r\n                    var canvas = document.querySelector('.visualizer') as HTMLCanvasElement;\r\n                    var canvasCtx = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\r\n\r\n                    // TODO: move this to a method\r\n                    var draw = () => {\r\n                        var WIDTH = canvas.width\r\n                        var HEIGHT = canvas.height;\r\n\r\n                        requestAnimationFrame(draw);\r\n\r\n                        analyser.getByteTimeDomainData(dataArray);\r\n\r\n                        this.waveform = this.waveform.concat(Array.from(dataArray));\r\n\r\n                        const maxSilence = 75000;\r\n                        if(this.state.status != \"recording\"){\r\n                            if(this.waveform.length > maxSilence){\r\n                                this.waveform = this.waveform.slice(this.waveform.length - maxSilence);\r\n                            }\r\n                        }\r\n\r\n                        var min = 100000000000000;\r\n                        var max = -100000000000000;\r\n                        dataArray.forEach(v => { min = Math.min(v, min); max = Math.max(v, max); });\r\n\r\n                        if (max > 140 || min < 100) {\r\n                            this.lastNoiseCounter = 0;\r\n                                // if we aren't recording we should start!\r\n                                if(this.state.status != \"recording\"){\r\n                                    this.record();\r\n                                }\r\n                        }\r\n                        else {\r\n                            this.lastNoiseCounter++;\r\n                            if(this.lastNoiseCounter > 15){\r\n                                // if we are recording we should stop!\r\n                                if(this.state.status == \"recording\"){\r\n                                    this.stop();\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        //fullBuffer = fullBuffer.concat(Array.from(dataArray));\r\n                        this.waveform.concat([min, max]);\r\n\r\n                        canvasCtx.fillStyle = 'rgb(200, 200, 200)';\r\n                        canvasCtx.fillRect(0, 0, WIDTH, HEIGHT);\r\n\r\n                        canvasCtx.lineWidth = 2;\r\n                        canvasCtx.strokeStyle = 'rgb(0, 0, 0)';\r\n\r\n\r\n                        var sliceWidth = WIDTH * 1.0 / this.waveform.length;\r\n                        var x = 0;\r\n\r\n                        var lastX = 0;\r\n                        var lastY = HEIGHT / 2;\r\n\r\n                        for (var i = 0; i < this.waveform.length; i++) {\r\n                            var v = this.waveform[i] / 128.0;\r\n                            var y = v * HEIGHT / 2;\r\n\r\n                            if (this.waveform[i] > 140 || this.waveform[i] < 100) {\r\n                                canvasCtx.strokeStyle = 'rgb(255, 0, 0)';\r\n\r\n                            }\r\n                            else {\r\n                                canvasCtx.strokeStyle = 'rgb(0, 0, 0)';\r\n                            }\r\n\r\n                            canvasCtx.beginPath();\r\n                            canvasCtx.moveTo(lastX, lastY);\r\n                            canvasCtx.lineTo(x, y);\r\n                            canvasCtx.stroke();\r\n\r\n                            lastX = x;\r\n                            lastY = y;\r\n\r\n                            x += sliceWidth;\r\n                        }\r\n\r\n                        canvasCtx.lineTo(canvas.width, canvas.height / 2);\r\n                        //canvasCtx.stroke();\r\n\r\n                    }\r\n\r\n                    draw();\r\n\r\n                    this.mediaRecorder = new MediaRecorder(stream, { mimeType: \"audio/webm\", audioBitsPerSecond: 320000 });\r\n                    this.mediaRecorder.onstart = e => {\r\n                        // reset our waveform and chunks\r\n                        this.chunks = [];\r\n                        this.waveform = [];\r\n                    }\r\n                    this.mediaRecorder.ondataavailable = (e) => {\r\n                        this.chunks.push(e.data);\r\n                    }\r\n                    this.mediaRecorder.onstop = (e) => {\r\n                        const name = \"test\";\r\n                        const blob = new Blob(this.chunks, { 'type': 'audio/webm' });\r\n                        this.chunks = [];\r\n                        const audioUrl = window.URL.createObjectURL(blob);\r\n                        const clipInfo: IClipInfo = {\r\n                            audioUrl,\r\n                            name: \"Track \" + this.trackCount,\r\n                            waveform: this.waveform,\r\n                            trackNumber: this.trackCount,\r\n                        };\r\n                        this.trackCount++;\r\n                        this.setState({ clips: [...this.state.clips, clipInfo] });\r\n                        this.waveform = [];\r\n\r\n                        var link = document.createElement(\"a\"); // Or maybe get it from the current document\r\n                        link.href = audioUrl;\r\n                        link.download = name + \".webm\";\r\n                        document.body.appendChild(link);\r\n                        //link.click();\r\n                    }\r\n                    this.setState({ status: \"ready\" });\r\n                }).catch(function (err) {\r\n                    console.error('The following getUserMedia error occured: ' + err);\r\n                }\r\n                );\r\n        }\r\n        else {\r\n            console.error('getUserMedia not supported on your browser!');\r\n        }\r\n\r\n        this.state = { status: \"initializing\", clips: [] };\r\n    }\r\n\r\n    public record = () => {\r\n        if (!this.mediaRecorder) {\r\n            throw \"No recorder!\";\r\n        }\r\n\r\n        this.mediaRecorder.start();\r\n        this.setState({ status: \"recording\" });\r\n    }\r\n\r\n    public pause = () => {\r\n        if (!this.mediaRecorder) {\r\n            throw \"No recorder!\";\r\n        }\r\n\r\n        this.mediaRecorder.pause();\r\n        this.setState({ status: \"paused\" });\r\n    }\r\n\r\n    public resume = () => {\r\n        if (!this.mediaRecorder) {\r\n            throw \"No recorder!\";\r\n        }\r\n\r\n        this.mediaRecorder.resume();\r\n        this.setState({ status: \"recording\" });\r\n    }\r\n\r\n    public split = () => {\r\n        if (!this.mediaRecorder) {\r\n            throw \"No recorder!\";\r\n        }\r\n\r\n    }\r\n\r\n    public stop = () => {\r\n        if (!this.mediaRecorder) {\r\n            throw \"No recorder!\";\r\n        }\r\n\r\n        this.mediaRecorder.stop();\r\n        this.setState({ status: \"ready\" }); // not sure this is right!\r\n    }\r\n\r\n    render() {\r\n        const { status, clips } = this.state;\r\n        return <div style={{ display: \"flex\", flexDirection: \"column\", height: \"100%\" }}>\r\n            <div style={{ overflow: \"auto\", flex: \"auto\", minHeight: \"50%\" }}>\r\n                {clips.map((clip, i) => {\r\n                    return <ClipInfo key={i} clipInfo={clip} />\r\n                })}\r\n            </div>\r\n            <div style={{ flex: \"none\" }}>\r\n                <canvas className=\"visualizer\" width=\"300\" height=\"100\" />\r\n                {status}\r\n                <div>\r\n                    {status == \"ready\" &&\r\n                        <button onClick={this.record}>Record</button>}\r\n                    {status == \"recording\" &&\r\n                        <button onClick={this.pause}>Pause</button>}\r\n                    {status == \"recording\" &&\r\n                        <button onClick={this.stop}>Stop</button>}\r\n                    {status == \"paused\" &&\r\n                        <button onClick={this.resume}>Resume</button>}\r\n                </div>\r\n            </div>\r\n        </div>;\r\n    }\r\n}","import React, { Component } from 'react';\nimport logo from './logo.svg';\nimport './App.css';\nimport { Recorder } from './recorder';\n\nclass App extends Component {\n  render() {\n    return (\n        <Recorder />\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}