{"version":3,"sources":["getusermedia.js","components/buttons/recordButton.tsx","components/buttons/stopButton.tsx","components/layout/buttonBar.tsx","components/layout/paddedBar.tsx","components/layout/screenWrapper.tsx","components/layout/titleBar.tsx","components/screens/baseScreen.tsx","components/visualizer.tsx","components/clipInfo.tsx","components/trackList.tsx","components/recorder.tsx","components/screens/startScreen.tsx","components/screens/listenScreen.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["promisifiedOldGUM","constraints","successCallback","errorCallback","getUserMedia","navigator","webkitGetUserMedia","mozGetUserMedia","msGetUserMedia","Promise","call","reject","Error","polyfillGUM","undefined","mediaDevices","RecordButton","_PureComponent","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","apply","arguments","inherits","createClass","key","value","size","props","react_default","a","createElement","onClick","title","style","height","width","borderRadius","backgroundColor","border","cursor","PureComponent","StopButton","ButtonBar","_Component","flex","display","flexDirection","direction","textAlign","justifyContent","alignItems","padding","children","Component","PaddedBar","ScreenWrapper","position","top","bottom","left","right","TitleBar","_this","_this$props","screen","marginBottom","fontSize","status","marginLeft","onScreenChange","BaseScreen","screenWrapper_ScreenWrapper","titleBar_TitleBar","Visualizer","_getPrototypeOf2","_len","length","args","Array","_key","concat","clipCanvas","canvasCtx","getContext","WIDTH","HEIGHT","fillStyle","fillRect","lineWidth","strokeStyle","sliceWidth","waveform","x","beginPath","moveTo","i","y","lineTo","stroke","_this2","ref","c","setState","ClipInfo","Audio","download","clipInfo","link","document","href","audioUrl","sessionName","trackName","body","appendChild","click","removeChild","showAudio","onDelete","onAudioPlayed","audioRef","margin","trackNumber","maxWidth","minWidth","visualizer_Visualizer","audio","onPlay","controls","marginTop","src","TrackList","audioElements","exceptClip","forEach","pause","clips","onClipPlayed","overflow","map","clip","clipInfo_ClipInfo","_onDelete","toString","stopAllClips","Recorder","mediaRecorder","analyser","dataBuffer","maxSilence","minSaveLength","lastClip","saveMode","lastNoiseCounter","chunks","trackCount","stream","saveClip","toConsumableArray","state","record","start","resume","split","stop","then","initializeAudioStream","canvas","querySelector","draw","requestAnimationFrame","readAnalyserData","console","log","catch","err","alert","getTracks","track","audioContext","AudioContext","audioSource","createMediaStreamSource","createAnalyser","connect","bufferLength","fftSize","Uint8Array","MediaRecorder","mimeType","audioBitsPerSecond","onstart","e","ondataavailable","push","data","onstop","blob","Blob","type","window","URL","createObjectURL","getByteTimeDomainData","min","max","Math","slice","autoStartStop","_this3","_this$state","baseScreen_BaseScreen","trackList_TrackList","splice","paddedBar_PaddedBar","className","buttonBar_ButtonBar","recordButton_RecordButton","stopButton_StopButton","StartScreen","onChange","onSessionNameChange","target","ListenScreen","App","setScreen","currentScreen","recorder_Recorder","listenScreen_ListenScreen","startScreen_StartScreen","Boolean","location","hostname","match","ReactDOM","render","src_App_0","getElementById","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.14307337.chunk.js","sourcesContent":["export var promisifiedOldGUM = function (constraints, successCallback, errorCallback) {\r\n    // First get ahold of getUserMedia, if present\r\n    var getUserMedia = (navigator.getUserMedia ||\r\n        navigator.webkitGetUserMedia ||\r\n        navigator.mozGetUserMedia ||\r\n        navigator.msGetUserMedia);\r\n\r\n    // Some browsers just don't implement it - return a rejected promise with an error\r\n    // to keep a consistent interface\r\n    if (!getUserMedia) {\r\n        return Promise.reject(new Error('getUserMedia is not implemented in this browser'));\r\n    }\r\n\r\n    // Otherwise, wrap the call to the old navigator.getUserMedia with a Promise\r\n    return new Promise(function (successCallback, errorCallback) {\r\n        getUserMedia.call(navigator, constraints, successCallback, errorCallback);\r\n    });\r\n\r\n}\r\n\r\nexport var polyfillGUM = function () {\r\n    // Older browsers might not implement mediaDevices at all, so we set an empty object first\r\n    if (navigator.mediaDevices === undefined) {\r\n        navigator.mediaDevices = {};\r\n    }\r\n\r\n    // Some browsers partially implement mediaDevices. We can't just assign an object\r\n    // with getUserMedia as it would overwrite existing properties.\r\n    // Here, we will just add the getUserMedia property if it's missing.\r\n    if (navigator.mediaDevices.getUserMedia === undefined) {\r\n        navigator.mediaDevices.getUserMedia = promisifiedOldGUM;\r\n    }\r\n}","import React, { Component, PureComponent } from 'react';\r\n\r\nexport interface IRecordButtonProps {\r\n    onClick: () => void;\r\n    title: string;\r\n    size?: string;\r\n}\r\n\r\nexport class RecordButton extends PureComponent<IRecordButtonProps> {\r\n    render() {\r\n        const size = this.props.size || \"75px\";\r\n        return <button\r\n            onClick={this.props.onClick}\r\n            title={this.props.title}\r\n            style={{\r\n                height: size,\r\n                width: size,\r\n                borderRadius: size,\r\n                backgroundColor: \"rgb(225,0,0)\",\r\n                border: \"none\",\r\n                cursor: \"pointer\"\r\n            }}\r\n        />\r\n    }\r\n}","import React, { Component, PureComponent } from 'react';\r\n\r\nexport interface IStopButtonProps {\r\n    onClick: () => void;\r\n    title: string;\r\n    size?: string;\r\n}\r\n\r\nexport class StopButton extends PureComponent<IStopButtonProps> {\r\n    render() {\r\n        const size = this.props.size || \"75px\";\r\n        return <button\r\n            onClick={this.props.onClick}\r\n            title={this.props.title}\r\n            style={{\r\n                height: size,\r\n                width: size,\r\n                backgroundColor: \"rgb(125,125,125)\",\r\n                border: \"none\",\r\n                cursor: \"pointer\"\r\n            }}\r\n        />\r\n    }\r\n}","import React, { Component } from 'react';\r\n\r\nexport class ButtonBar extends Component<{ direction?: \"row\" | \"column\" }> {\r\n    render() {\r\n        return (\r\n            <div\r\n                style={{\r\n                    flex: \"none\",\r\n                    display: \"flex\",\r\n                    flexDirection: (this.props.direction || \"row\"),\r\n                    textAlign: \"center\",\r\n                    justifyContent: \"space-around\",\r\n                    alignItems: \"center\",\r\n                    padding: \"5px\"\r\n                }}\r\n            >\r\n                {this.props.children}\r\n            </div>\r\n        );\r\n    }\r\n}","import React, { Component } from 'react';\r\n\r\nexport class PaddedBar extends Component {\r\n    render() {\r\n        return (\r\n            <div\r\n                style={{ \r\n                    padding: \"10% 15px\",\r\n                    display: \"flex\" \r\n                }}\r\n            >\r\n                {this.props.children}\r\n            </div>\r\n        );\r\n    }\r\n}","import React, { Component } from 'react';\r\n\r\nexport class ScreenWrapper extends Component {\r\n    render() {\r\n        return (\r\n            <div\r\n                style={{\r\n                    position: \"absolute\",\r\n                    top: \"5%\",\r\n                    bottom: \"5%\",\r\n                    left: \"5%\",\r\n                    right: \"5%\",\r\n                    display: \"flex\",\r\n                    flexDirection: \"column\",\r\n                    justifyContent: \"flex-end\",\r\n                }}\r\n            >\r\n                {this.props.children}\r\n            </div>\r\n        );\r\n    }\r\n}","import React, { Component } from 'react';\r\nimport { CurrentScreen } from '../screens/baseScreen';\r\n\r\nexport interface ITitleBarProps {\r\n    title?: string,\r\n    screen: CurrentScreen,\r\n    onScreenChange: (newScreen: CurrentScreen) => void\r\n};\r\n\r\nexport class TitleBar extends Component<ITitleBarProps> {\r\n    render() {\r\n        const { title, screen } = this.props;\r\n        return (\r\n            <div\r\n                style={{\r\n                    justifyContent: \"space-between\",\r\n                    alignItems: \"center\",\r\n                    marginBottom: \"auto\",\r\n                    display: \"flex\",\r\n                    fontSize: \"125%\"\r\n                }}>\r\n                {(status == \"recording\" || status == \"armed\") && \"Recording\"}\r\n                {title}\r\n                {(screen == \"record\" || screen ==\"start\") && <button style={{ marginLeft: \"auto\" }} onClick={() => { this.props.onScreenChange(\"listen\") }}>Listen</button>}\r\n                {screen == \"listen\" && <button style={{ marginLeft: \"auto\" }} onClick={() => { this.props.onScreenChange(\"record\") }}>Record</button>}\r\n            </div>\r\n        );\r\n    }\r\n}","import React, { Component } from 'react';\r\nimport { RecordButton } from '../buttons/recordButton';\r\nimport { ButtonBar } from '../layout/buttonBar';\r\nimport { ScreenWrapper } from '../layout/screenWrapper';\r\nimport { TitleBar, ITitleBarProps } from '../layout/titleBar';\r\nimport { PaddedBar } from '../layout/paddedBar';\r\n\r\nexport type CurrentScreen = \"start\" | \"record\" | \"listen\";\r\n\r\nexport interface IScreenProps extends ITitleBarProps {\r\n}\r\n\r\nexport class BaseScreen extends Component<IScreenProps> {\r\n    render() {\r\n        return (\r\n            <ScreenWrapper>\r\n                <TitleBar title={this.props.title} screen={this.props.screen} onScreenChange={this.props.onScreenChange} />\r\n                {this.props.children}\r\n            </ScreenWrapper>\r\n        );\r\n    }\r\n}","import React, { Component } from 'react';\r\n\r\nexport interface IVisualizerProps {\r\n    waveform: number[];\r\n}\r\n\r\nexport interface IVisualizerState {\r\n    clipCanvas?: HTMLCanvasElement;\r\n}\r\n\r\nexport class Visualizer extends Component<IVisualizerProps, IVisualizerState> {\r\n    clipCanvas: HTMLCanvasElement | null = null;\r\n\r\n    componentDidUpdate() {\r\n        if (!this.clipCanvas) { return; }\r\n        var canvasCtx = this.clipCanvas.getContext(\"2d\") as CanvasRenderingContext2D;\r\n\r\n        var WIDTH = this.clipCanvas.width\r\n        var HEIGHT = this.clipCanvas.height;\r\n\r\n        canvasCtx.fillStyle = 'rgb(25, 25, 25)';\r\n        canvasCtx.fillRect(0, 0, WIDTH, HEIGHT);\r\n\r\n        canvasCtx.lineWidth = 2;\r\n        canvasCtx.strokeStyle = 'rgb(125, 125, 125)';\r\n\r\n        var sliceWidth = WIDTH * 1.0 / this.props.waveform.length;\r\n        var x = 0;\r\n        canvasCtx.beginPath();\r\n        canvasCtx.moveTo(0, HEIGHT / 2);\r\n\r\n        for (var i = 0; i < this.props.waveform.length; i++) {\r\n            var v = this.props.waveform[i] / 128.0;\r\n            var y = v * HEIGHT / 2;\r\n            canvasCtx.lineTo(x, y);\r\n            x += sliceWidth;\r\n        }\r\n\r\n        canvasCtx.stroke();\r\n    }\r\n\r\n    render() {\r\n        return <canvas height=\"100\" width=\"1000\" ref={c => { if(!this.clipCanvas && c){\r\n            this.clipCanvas = c;\r\n            this.setState({clipCanvas: c});\r\n        } }} style={{ flex: \"auto\" }} />;\r\n    }\r\n}","import React, { Component } from 'react';\r\nimport { Visualizer } from './visualizer';\r\n\r\nexport interface IClipInfo {\r\n    sessionName: string;\r\n    audioUrl: string;\r\n    trackName: string;\r\n\r\n    //todo: add other information like length, date and wave preview\r\n    waveform: number[];\r\n    trackNumber: number;\r\n}\r\n\r\nexport interface IClipInfoProps {\r\n    clipInfo: IClipInfo;\r\n    onDelete: () => void;\r\n    showAudio?: boolean;\r\n    onAudioPlayed?: () => void;\r\n    audioRef?: (audio: HTMLAudioElement) => void;\r\n}\r\n\r\nexport class ClipInfo extends Component<IClipInfoProps> {\r\n    public Audio: HTMLAudioElement | null = null;\r\n    private clipCanvas: HTMLCanvasElement | null = null;\r\n\r\n    private download = () => {\r\n        const { clipInfo } = this.props;\r\n        var link = document.createElement(\"a\"); // Or maybe get it from the current document\r\n        link.href = clipInfo.audioUrl;\r\n        link.download = (clipInfo.sessionName ? clipInfo.sessionName + \"_\" : \"\") + clipInfo.trackName + \".webm\";\r\n        document.body.appendChild(link);\r\n        this.download && link.click();\r\n        document.body.removeChild(link);\r\n    }\r\n\r\n    render() {\r\n        const { clipInfo, showAudio, onDelete, onAudioPlayed, audioRef } = this.props;\r\n        return (\r\n            <div style={{ display: \"flex\", flexDirection: \"row\", height: \"100px\", margin: \"5px\" }}>\r\n                <div style={{ flex: \"none\", display: \"flex\", alignItems: \"center\", margin: \"5px\" }}>{clipInfo.trackNumber}</div>\r\n                <div style={{ flex: \"auto\", display: \"flex\", flexDirection: \"column\", maxWidth: \"80%\", minWidth: \"50%\" }}>\r\n                    <Visualizer waveform={clipInfo.waveform} />\r\n                    {showAudio &&\r\n                        <audio\r\n                            ref={audio => {\r\n                                if (audio && audioRef) { audioRef(audio); }\r\n                                this.Audio = this.Audio || audio;\r\n                            }}\r\n                            onPlay={onAudioPlayed}\r\n                            controls\r\n                            style={{\r\n                                width: \"100%\",\r\n                                height: \"40px\",\r\n                                marginTop: \"10px\"\r\n                            }}\r\n                            src={clipInfo.audioUrl}\r\n                        />\r\n                    }\r\n                </div>\r\n                <div style={{ margin: \"5px\", justifyContent: \"space-around\", flex: \"none\", display: \"flex\", flexDirection: \"column\" }}>\r\n                    <div style={{ flex: \"none\" }}>\r\n                        {clipInfo.trackName}\r\n                    </div>\r\n                    <div style={{ flex: \"none\" }}>\r\n                        <button onClick={onDelete}>Delete</button>\r\n                    </div>\r\n                    <div style={{ flex: \"none\" }}>\r\n                        <button onClick={this.download}>Download</button>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}","import React, { Component } from 'react';\r\nimport { IClipInfo, ClipInfo } from './clipInfo';\r\n\r\nexport class TrackList extends Component<{ clips: IClipInfo[], onClipPlayed?: () => void, onDelete: (index: number) => void }> {\r\n    private audioElements: HTMLAudioElement[] = [];\r\n    public stopAllClips(exceptClip?: number) {\r\n        this.audioElements.forEach((a, i) => {\r\n            if (exceptClip != i) {\r\n                a.pause();\r\n            }\r\n        });\r\n    }\r\n\r\n    render() {\r\n        const { clips, onClipPlayed, onDelete } = this.props;\r\n        return (\r\n            <div style={{ overflow: \"auto\", flex: \"auto\", margin: \"25px 10px\" }}>\r\n                {clips.map((clip, i) => {\r\n                    return <ClipInfo\r\n                        showAudio\r\n                        audioRef={a => { if (a) { this.audioElements[i] = a; } }}\r\n                        key={i}\r\n                        clipInfo={clip}\r\n                        onDelete={() => { onDelete(i); }}\r\n                        onAudioPlayed={() => {\r\n                            // stop other audio clips\r\n                            this.stopAllClips(i);\r\n\r\n                            // stop recording (handled in parent)\r\n                            onClipPlayed && onClipPlayed();\r\n                        }}\r\n                    />\r\n                })}\r\n            </div>\r\n        );\r\n    }\r\n}","import { polyfillGUM } from \"../getusermedia\";\r\nimport React, { Component } from 'react';\r\nimport { ClipInfo, IClipInfo } from \"./clipInfo\";\r\nimport { TitleBar } from \"./layout/titleBar\";\r\nimport { ScreenWrapper } from \"./layout/screenWrapper\";\r\nimport { RecordButton } from \"./buttons/recordButton\";\r\nimport { StopButton } from \"./buttons/stopButton\";\r\nimport { ButtonBar } from \"./layout/buttonBar\";\r\nimport { PaddedBar } from \"./layout/paddedBar\";\r\nimport { IScreenProps, BaseScreen } from \"./screens/baseScreen\";\r\nimport { TrackList } from \"./trackList\";\r\n\r\nexport interface IRecorderProps extends IScreenProps {\r\n}\r\n\r\nexport interface IRecorderState {\r\n    lastClip?: IClipInfo;\r\n    clips: IClipInfo[];\r\n    status: \"initializing\" | \"ready\" | \"armed\" | \"recording\" | \"done\" | \"paused\" | \"error\"; // it looks like mediarecorder is reusable after stopping.\r\n    recording?: \"waiting for audio\" | \"detected sound recently\" | \"recording a track\";\r\n}\r\n\r\nexport class Recorder extends Component<IRecorderProps, IRecorderState> {\r\n    private mediaRecorder?: MediaRecorder;\r\n    private analyser?: AnalyserNode;\r\n    private dataBuffer?: Uint8Array;\r\n\r\n    private readonly maxSilence = 100;\r\n    private readonly minSaveLength = 1000;\r\n    private lastClip?: IClipInfo;\r\n    private saveMode: \"saveNext\" | \"autodecide\" | \"skipNext\" = \"autodecide\";\r\n    private lastNoiseCounter = 0;\r\n\r\n    // currently recording chunks\r\n    private chunks: Blob[] = [];\r\n\r\n    // currently recording chunks\r\n    private waveform: number[] = [];\r\n\r\n    private trackCount = 1;\r\n\r\n    stream?: MediaStream;\r\n\r\n    constructor(props: IRecorderProps) {\r\n        super(props);\r\n        polyfillGUM();\r\n        if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\r\n            navigator.mediaDevices.getUserMedia({ audio: true })\r\n                .then(stream => {\r\n                    this.initializeAudioStream(stream);\r\n\r\n                    const canvas = document.querySelector('.visualizer') as HTMLCanvasElement;\r\n                    const canvasCtx = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\r\n                    canvasCtx.fillStyle = 'rgb(25, 25, 25)';\r\n                    canvasCtx.lineWidth = 2;\r\n\r\n                    // TODO: move this to a method\r\n                    const draw = () => {\r\n                        requestAnimationFrame(draw);\r\n\r\n                        // how do we update this data while not recording?\r\n                        // but also not do duplicates here?\r\n                        this.readAnalyserData();\r\n\r\n                        const WIDTH = canvas.width\r\n                        const HEIGHT = canvas.height;\r\n                        canvasCtx.fillRect(0, 0, WIDTH, HEIGHT);\r\n                        if (this.state.status == \"recording\") {\r\n                            canvasCtx.strokeStyle = 'rgb(225, 0, 0)';\r\n                        }\r\n                        else {\r\n                            canvasCtx.strokeStyle = 'rgb(75, 75, 75)';\r\n                        }\r\n\r\n                        const sliceWidth = WIDTH * 1.0 / this.waveform.length;\r\n                        let x = 0;\r\n\r\n                        canvasCtx.beginPath();\r\n                        canvasCtx.moveTo(0, HEIGHT / 2);\r\n                        for (let i = 0; i < this.waveform.length; i++) {\r\n                            const v = this.waveform[i] / 128.0;\r\n                            const y = v * HEIGHT / 2;\r\n                            canvasCtx.lineTo(x, y);\r\n                            x += sliceWidth;\r\n                        }\r\n\r\n                        canvasCtx.lineTo(canvas.width, canvas.height / 2);\r\n                        canvasCtx.stroke();\r\n                    }\r\n\r\n                    draw();\r\n\r\n\r\n                    // actually lets go straight to armed. default is to go to \"ready\"\r\n                    console.log(\"armed and ready!\")\r\n                    this.setState({ status: \"armed\" });\r\n\r\n                }).catch(function (err) {\r\n                    alert('The following getUserMedia error occured: ' + err);\r\n                });\r\n        }\r\n        else {\r\n            alert('getUserMedia not supported on your browser!');\r\n        }\r\n\r\n        this.state = { status: \"initializing\", clips: [] };\r\n    }\r\n\r\n    componentDidMount() {\r\n\r\n    }\r\n\r\n    componentWillUnmount() {\r\n        if (this.stream) { this.stream.getTracks().forEach(track => track.stop()) }\r\n    }\r\n\r\n    private initializeAudioStream(stream: MediaStream) {\r\n        this.stream = stream;\r\n\r\n        // Set up AnalyserNode for waveform rendering\r\n        var audioContext = new AudioContext();\r\n        var audioSource = audioContext.createMediaStreamSource(stream);\r\n        this.analyser = audioContext.createAnalyser();\r\n        audioSource.connect(this.analyser);\r\n        var bufferLength = this.analyser.fftSize;\r\n        this.dataBuffer = new Uint8Array(bufferLength);\r\n\r\n        // Set up MediaRecorder for recording (obviously)\r\n        this.mediaRecorder = new MediaRecorder(stream, { mimeType: \"audio/webm\", audioBitsPerSecond: 320000 });\r\n        this.mediaRecorder.onstart = e => {\r\n            // reset our waveform and chunks\r\n            this.chunks = [];\r\n            this.waveform = [];\r\n        }\r\n        this.mediaRecorder.ondataavailable = (e) => {\r\n            this.chunks.push(e.data);\r\n\r\n            // here is where we should save the waveform as well\r\n            this.readAnalyserData();\r\n        }\r\n        this.mediaRecorder.onstop = (e) => {\r\n            // probably should reset the waveform..?\r\n            const blob = new Blob(this.chunks, { 'type': 'audio/webm' });\r\n            const audioUrl = window.URL.createObjectURL(blob);\r\n            const clipInfo: IClipInfo = {\r\n                audioUrl,\r\n                waveform: this.waveform,\r\n            } as IClipInfo;\r\n\r\n            this.chunks = [];\r\n            this.waveform = [];\r\n\r\n            // this is where we should decide if we keep it or not...\r\n            // if it is really short DONT keep it.\r\n\r\n            this.lastClip = clipInfo;\r\n            this.setState({ lastClip: clipInfo });\r\n            if (this.saveMode == \"autodecide\") {\r\n                console.log(\"waveform length: \" + clipInfo.waveform.length)\r\n                if (clipInfo.waveform.length < this.minSaveLength) {\r\n                    console.log(\"skip saving the track since it is so short\");\r\n                    return;\r\n                }\r\n\r\n                // also skip if it has very little CONTENT as a percentage. especially for very short lcips.\r\n            }\r\n            if (this.saveMode == \"skipNext\") {\r\n                // only skip one\r\n                this.saveMode = \"autodecide\";\r\n                console.log(\"skip saving because we are in skipNext save mode\");\r\n                return;\r\n            }\r\n            if (this.saveMode == \"saveNext\") {\r\n                // only save one\r\n                this.saveMode = \"autodecide\";\r\n                console.log(\"force saving because we are in saveNext save mode\");\r\n            }\r\n\r\n            this.saveClip(clipInfo);\r\n        }\r\n    }\r\n\r\n    private readAnalyserData() {\r\n        if (!this.analyser || !this.dataBuffer) { throw \"missing analyser node or data buffer!\"; }\r\n        this.analyser.getByteTimeDomainData(this.dataBuffer);\r\n        var min = 100000000000000;\r\n        var max = -100000000000000;\r\n        this.dataBuffer.forEach(value => { min = Math.min(value, min); max = Math.max(value, max); });\r\n        this.waveform = this.waveform.concat([min, max]);\r\n\r\n        // This is really just so the waveform \"scrolls\" when in the armed state.\r\n        if (this.state.status != \"recording\") {\r\n            // there are some... race conditions here depending on when the recording gets stopped.\r\n            // should either fix this or ensure we don't trim VALID recordings\r\n            // it should never be able to get out of this region, but bad things would happen if it did?\r\n            if (this.waveform.length > this.maxSilence && this.waveform.length < this.minSaveLength) {\r\n                this.waveform = this.waveform.slice(this.waveform.length - this.maxSilence);\r\n            }\r\n        }\r\n\r\n        // Decide whether to start or stop recording\r\n        this.autoStartStop(min, max);\r\n    }\r\n\r\n    private autoStartStop(min: number, max: number) {\r\n        if (max > 140 || min < 100) {\r\n            this.lastNoiseCounter = 0;\r\n            // if we aren't recording we should start\r\n            if (this.state.status == \"armed\") {\r\n                this.record();\r\n            }\r\n        }\r\n        else {\r\n            this.lastNoiseCounter++;\r\n            if (this.lastNoiseCounter > this.maxSilence) {\r\n                // if we are recording we should stop but stay armed\r\n                if (this.state.status == \"recording\") {\r\n                    this.split();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private saveClip = (clipInfo: IClipInfo) => {\r\n        clipInfo.trackName = \"Track \" + this.trackCount;\r\n        clipInfo.trackNumber = this.trackCount;\r\n        this.trackCount++;\r\n        this.setState({ clips: [...this.state.clips, clipInfo], lastClip: undefined });\r\n        this.lastClip = undefined;\r\n        this.waveform = [];\r\n    }\r\n\r\n    public record = () => {\r\n        if (!this.mediaRecorder) {\r\n            throw \"No recorder!\";\r\n        }\r\n\r\n        this.mediaRecorder.start();\r\n        this.setState({ status: \"recording\" });\r\n    }\r\n\r\n    public pause = () => {\r\n        if (!this.mediaRecorder) {\r\n            throw \"No recorder!\";\r\n        }\r\n\r\n        this.mediaRecorder.pause();\r\n        this.setState({ status: \"paused\" });\r\n    }\r\n\r\n    public resume = () => {\r\n        if (!this.mediaRecorder) {\r\n            throw \"No recorder!\";\r\n        }\r\n\r\n        this.mediaRecorder.resume();\r\n        this.setState({ status: \"recording\" });\r\n    }\r\n\r\n    public split = () => {\r\n        if (!this.mediaRecorder) {\r\n            throw \"No recorder!\";\r\n        }\r\n\r\n        this.mediaRecorder.stop();\r\n        this.setState({ status: \"armed\" }); // not sure this is right!\r\n    }\r\n\r\n    public stop = () => {\r\n        if (!this.mediaRecorder) {\r\n            throw \"No recorder!\";\r\n        }\r\n\r\n        if (this.mediaRecorder.state == \"recording\" || this.mediaRecorder.state == \"paused\") {\r\n            this.mediaRecorder.stop();\r\n        }\r\n\r\n        this.setState({ status: \"ready\" });\r\n    }\r\n\r\n    render() {\r\n        const { status, clips, lastClip } = this.state;\r\n        return (\r\n            <BaseScreen title={\"Recording \" + (this.props.title || \"\")} screen=\"record\" onScreenChange={this.props.onScreenChange}>\r\n                <TrackList\r\n                    clips={clips}\r\n                    onClipPlayed={this.stop}\r\n                    onDelete={i => {\r\n                        var removed = clips.splice(i, 1);\r\n                        this.setState({ clips: clips.slice() })\r\n                    }}\r\n                />\r\n                <PaddedBar>\r\n                    <canvas className=\"visualizer\" height=\"100\" width=\"1000\" style={{ width: \"100%\" }} />\r\n                </PaddedBar>\r\n                <ButtonBar>\r\n                    {(status != \"recording\" && lastClip) && <button onClick={() => { this.saveClip(lastClip); }}>Save</button>}\r\n                    {(status == \"recording\") && <button onClick={() => { this.saveMode = \"saveNext\"; this.split() }}>Save</button>}\r\n\r\n                    {status == \"ready\" &&\r\n                        <RecordButton\r\n                            onClick={() => { this.setState({ status: \"armed\" }) }}\r\n                            title=\"Arm for recording\"\r\n                        />\r\n                    }\r\n\r\n                    {(status == \"recording\" || status == \"armed\") &&\r\n                        <StopButton\r\n                            onClick={this.stop}\r\n                            title=\"Stop\"\r\n                        />\r\n                    }\r\n\r\n                    {(status != \"recording\" && lastClip) && <button onClick={() => { this.setState({ lastClip: undefined }) }}>Skip</button>}\r\n                    {(status == \"recording\") && <button onClick={() => { this.saveMode = \"skipNext\"; this.split() }}>Skip</button>}\r\n                </ButtonBar>\r\n            </BaseScreen>\r\n        );\r\n    }\r\n}","import React, { Component } from 'react';\r\nimport { RecordButton } from '../buttons/recordButton';\r\nimport { ButtonBar } from '../layout/buttonBar';\r\nimport { ScreenWrapper } from '../layout/screenWrapper';\r\nimport { TitleBar } from '../layout/titleBar';\r\nimport { PaddedBar } from '../layout/paddedBar';\r\nimport { BaseScreen, IScreenProps } from './baseScreen';\r\n\r\nexport interface IStartScreenProps extends IScreenProps {\r\n    onSessionNameChange: (name: string) => void;\r\n}\r\n\r\nexport class StartScreen extends Component<IStartScreenProps> {\r\n    render() {\r\n        return (\r\n            <BaseScreen title=\"Session Recorder\" screen={this.props.screen} onScreenChange={this.props.onScreenChange}>\r\n                <PaddedBar>\r\n                    <input\r\n                        onChange={e => {\r\n                            this.props.onSessionNameChange(e.target.value);\r\n                        }}\r\n                        type=\"textfield\"\r\n                        style={{\r\n                            maxWidth: \"calc(100% - 20px)\",\r\n                            height: \"50px\",\r\n                            flex: \"auto\",\r\n                            fontSize: \"150%\",\r\n                            padding: \"0 10px\",\r\n                            textAlign: \"center\"\r\n                        }}\r\n                    />\r\n                </PaddedBar>\r\n                <ButtonBar>\r\n                    <RecordButton\r\n                        onClick={()=>{this.props.onScreenChange(\"record\")}}\r\n                        title=\"Start a new session\"\r\n                    />\r\n                </ButtonBar>\r\n            </BaseScreen>\r\n        );\r\n    }\r\n}","import React, { Component } from 'react';\r\nimport { ScreenWrapper } from '../layout/screenWrapper';\r\nimport { TitleBar } from '../layout/titleBar';\r\nimport { IScreenProps, BaseScreen } from './baseScreen';\r\nimport { PaddedBar } from '../layout/paddedBar';\r\n\r\nexport interface IListScreenProps extends IScreenProps {\r\n}\r\n\r\nexport class ListenScreen extends Component<IListScreenProps> {\r\n    render() {\r\n        return (\r\n            <BaseScreen title={this.props.title} screen={this.props.screen} onScreenChange={this.props.onScreenChange}>\r\n                <PaddedBar>Listening!</PaddedBar>\r\n            </BaseScreen>\r\n        );\r\n    }\r\n}","import React, { Component } from 'react';\nimport logo from './logo.svg';\nimport './App.css';\nimport { Recorder } from './components/recorder';\nimport { StartScreen } from './components/screens/startScreen';\nimport { ListenScreen } from './components/screens/listenScreen';\nimport { CurrentScreen } from './components/screens/baseScreen';\n\n// App has 3 states. Start, Record and Listen\nexport type Screen = \"start\" | \"record\" | \"listen\";\n\ninterface IAppProps {\n}\n\ninterface IAppState {\n  currentScreen: Screen;\n  sessionName?: string;\n}\n\nclass App extends Component<IAppProps, IAppState> {\n  constructor(props: IAppProps) {\n    super(props);\n    this.state = { currentScreen: \"start\" };\n  }\n\n  private setScreen = (currentScreen: CurrentScreen) => {\n    this.setState({ currentScreen });\n  }\n\n  render() {\n    const { currentScreen } = this.state;\n    switch (currentScreen) {\n      case \"record\":\n        // current functionality is in <Recorder>\n        return <Recorder\n          screen={this.state.currentScreen}\n          onScreenChange={this.setScreen}\n          title={this.state.sessionName}\n        />;\n      case \"listen\":\n        return <ListenScreen\n          title={this.state.sessionName}\n          screen={this.state.currentScreen}\n          onScreenChange={this.setScreen}\n        />\n      case \"start\":\n      default:\n        return <StartScreen\n          title={this.state.sessionName}\n          screen={this.state.currentScreen}\n          onScreenChange={this.setScreen}\n          onSessionNameChange={sessionName => { this.setState({ sessionName }) }}\n        />\n    }\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}